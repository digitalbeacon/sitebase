<macro name="ClientFormRow" options="FormRowOptions" clientEvents="dynamic" clientModel="string" initClientModel="bool">

	<set options.RowId="'form-row-' + options.Property.ToLowerHyphenated()" if="options.GenerateRowId && options.Property.HasText()" />
	<set options.RowId="options.RowId + '-' + options.SubProperty.ToLowerHyphenated()" if="options.GenerateRowId && options.SubProperty.HasText()" />
	<set options.RowClass="' ' + options.RowClass" if="options.RowClass.HasText()" />

	<if condition="options.Property.HasText()">
		<var propName="options.Property" />
		<if condition="options.SubProperty.IsNullOrBlank() && propName.IndexOf('.') >= 0">
			<set options.Property="propName.Substring(0, propName.IndexOf('.'))" />
			<set options.SubProperty="propName.Substring(propName.IndexOf('.') + 1)" />
		</if>
		<set propName="Model.GetType().GetProperty(options.Property).Name" />
		<set propName="'{0}.{1}'.FormatWith(propName, options.Model.GetType().GetProperty(options.Property).PropertyType.GetProperty(options.SubProperty).Name)" if="options.SubProperty.HasText()" />
		<var clientPropName="'data.{0}.{1}'.FormatWith(clientModel, propName)" />
		<var propMetadata="ModelMetadata.FromStringExpression(propName, options.ViewData)" />
		<var propRequired="options.Required.HasValue ? options.Required.Value : propMetadata.IsRequired" />
		<var propReadOnly="options.InputReadOnly.HasValue ? options.InputReadOnly.Value : propMetadata.IsReadOnly" />
		<set initClientModel="false" if="initClientModel && propMetadata.Model.ToStringSafe().IsNullOrBlank()" />
		<default ngInitValue="string.Empty" />
		<set ngInitValue="'{0}=\'{1:M/d/yyyy}\''.FormatWith(clientPropName, propMetadata.Model)" if="initClientModel && (propMetadata.ModelType == typeof(DateTime) || propMetadata.ModelType == typeof(DateTime?))" />
		<set ngInitValue="'{0}={2}{1}{2}'.FormatWith(clientPropName, propMetadata.Model, propMetadata.ModelType.IsPrimitive ? '\'' : String.Empty)" if="initClientModel && ngInitValue.IsNullOrBlank()" />
		
		<if condition="options.InputType == null">
			<if condition="propMetadata.ModelType == typeof(bool) || propMetadata.ModelType == typeof(bool?)">
				<set options.InputType="checkBox" />
			</if>
			<else if="propMetadata.ModelType == typeof(DateTime) || propMetadata.ModelType == typeof(DateTime?)">
				<set options.InputType="date" />
			</else>
			<else if="options.Model.ListItems.ContainsKey(propName)">
				<set options.InputType="dropDownList" />
			</else>
		</if>
		<var ngFormProp="'{0}.{1}'.FormatWith(options.FormPanelId, propName)" />

		<var attr="new Dictionary[[string,object]]()" />
		<var validationErrors="new Dictionary[[string,object]]()" />

		<for each="var v in Html.GetUnobtrusiveValidationAttributes(propName)">
			<sbSet dictionary="validationErrors" key="'required'" value="v.Value" if="v.Key == 'data-val-required'" />
			<sbSet dictionary="validationErrors" key="'pattern'" value="v.Value" if="v.Key == 'data-val-regex'" />
			<sbSet dictionary="validationErrors" key="'maxlength'" value="v.Value" if="v.Key == 'data-val-length'" />
			<sbSet dictionary="validationErrors" key="'date'" value="v.Value" if="v.Key == 'data-val-date'" />
			<sbSet dictionary="attr" key="'maxlength'" value="v.Value" if="v.Key == 'data-val-length-max'" />
			<sbSet dictionary="attr" key="'ng-maxlength'" value="v.Value" if="v.Key == 'data-val-length-max'" />
			<sbSet dictionary="attr" key="'ng-pattern'" value="'/' + v.Value.ToString() + '/'" if="v.Key == 'data-val-regex-pattern'" />
		</for>
		
		<sbSet dictionary="validationErrors" key="'required'" value="Text('Validation.Error.Required', propMetadata.DisplayName)" if="propRequired && !validationErrors.ContainsKey('required')" />
		<sbSet dictionary="attr" key="'ng-model'" value="clientPropName" />
		<sbSet dictionary="attr" key="'ng-init'" value="ngInitValue" if="ngInitValue.HasText()" />
		<sbSet dictionary="attr" key="'class'" value="'form-control'" />
		<sbSet dictionary="attr" key="'required'" value="string.Empty" if="propRequired" />
		<sbSet dictionary="attr" key="'readonly'" value="string.Empty" if="propReadOnly" />
		<sbSet dictionary="attr" key="'maxlength'" value="options.MaxLength.ToString()" if="options.MaxLength.HasValue" />
		<sbSet dictionary="attr" key="'ui-mask'" value="options.Mask" if="options.Mask.HasText()" />
		<sbSet dictionary="attr" key="'popover'" value="Text(options.HelpText)" if="options.HelpText.HasText()" />
		<sbSet dictionary="attr" key="'popover-trigger'" value="'focus'" if="options.HelpText.HasText()" />
		
		<var displayLabel="options.InputType != checkBox" />
		
		<div id="${options.RowId}?{options.RowId.HasText()}" class="form-row form-group has-feedback${options.RowClass}" style="${options.RowStyle}?{options.RowStyle.HasText()}"
			 ng-class="{ 'has-error' : ${ngFormProp}.$invalid && (!${ngFormProp}.$pristine || data.${clientModel}.submitted) }">
			<span class="form-row-label" if="displayLabel && propMetadata.DisplayName.HasText()">
				${Html.Label(propName, new { class = "control-label" })}
				<span class="form-row-required"><span class="fa fa-asterisk" tooltip="${Text('Common.Required.Label')}" if="propRequired"></span></span>
			</span>
			#//<span class="fa fa-info-sign" if="options.HelpText.HasText()"></span>
			<span class="form-row-content">
				<if condition="options.InputType == textArea">
					${this.TextArea(propName).DoNotAutoLabel().Class("form-control").Attr("ng-model", clientPropName).Attr("ng-required", propRequired ? "true" : "false")}
				</if>
				<else if="options.InputType == password">
					${Html.Editor(propName, "string", new { inputType = password, htmlAttributes = attr })}
				</else>
				<else if="options.InputType == date">
					<span class="input-group">
						<sbSet dictionary="attr" key="'datepicker-popup'" value="'M/d/yyyy'" />
						<sbSet dictionary="attr" key="'is-open'" value="'data.isOpen' + propName" />
						${Html.Editor(propName, "string", new { htmlAttributes = attr })}
						<span class="input-group-btn">
							<button type="button" class="btn btn-default" ng-click="toggle($event, 'isOpen${propName}')"><i class="fa fa-calendar"></i></button>
						</span>
					</span>
				</else>
				<else if="options.InputType == radioButtonList">
					<div class="btn-group btn-group-justified input-group">
						<for each="var listItem in options.Model.ListItems[propName]">
							${this.Label(propName).Value(listItem.Text).Class("btn btn-default").Attr("ng-model", clientPropName).Attr("btn-radio", listItem.Value).Attr("uncheckable", string.Empty)}
						</for>
					</div>
					<div class="ng-hide" ng-init="${ngInitValue}" if="initClientModel"></div>
				</else>
				<else if="options.InputType == dropDownList">
					<if condition="options.IncludeEmptyOption">
						${Html.DropDownList(propName, options.Model.ListItems[propName], String.Empty, attr)}
					</if>
					<else>
						${Html.DropDownList(propName, options.Model.ListItems[propName], attr)}
					</else>
					<div class="ng-hide" ng-init="${ngInitValue}" if="initClientModel"></div>
				</else>
				<else if="options.InputType == checkBox">
					<div class="checkbox">
						<label>
							${this.CheckBox(propName).Attr("ng-model", clientPropName)}
							${propMetadata.DisplayName}
						</label>
					</div>
				</else>
				<else if="options.InputType == file">
					<if condition="options.InputSize > 0">
						${this.FileUpload(propName).DoNotAutoLabel().Attr("onchange", "angular.element(this).scope().fileChanged(this)").Size(options.InputSize)}
					</if>
					<else>
						${this.FileUpload(propName).DoNotAutoLabel().Attr("onchange", "angular.element(this).scope().fileChanged(this)")}
					</else>
				</else>
				<else>
					${Html.Editor(propName, null, new { htmlAttributes = attr })}
				</else>
				${options.RenderContent}
			</span>
			<for each="var v in validationErrors">
				<span ng-show="${ngFormProp}.$error.${v.Key} && (!${ngFormProp}.$pristine || data.${clientModel}.submitted)" class="ng-hide help-block">${v.Value}</span>
			</for>
			#//<span class="fa fa-asterisk form-control-feedback" tooltip="${Text('Common.Required.Label')}" if="propRequired"></span>
		</div>
		<content name="readyScript" if="options.Focus">
			setTimeout(function() { $('#${options.FormPanelId} #${propName.Replace(".", "_")}').focus(); }, 0);
		</content>
	</if>
	<else>
		<div id="${options.RowId}?{options.RowId.HasText()}" class="form-row form-group${options.RowClass}" style="${options.RowStyle}?{options.RowStyle.HasText()}">
			<span class="form-row-content">
				<if condition="options.InputType == submit">
					<var customText="options.CustomText" />
					<set customText="'Common.Save.Label'" if="customText == null && options.IsEntityModel" />
					<set customText="'Common.Submit.Label'" if="customText == null && !options.IsEntityModel" />
					<div>
						<button if="options.EnableSave" type="submit" id="save" class="btn btn-primary ${options.InputClass}?{options.InputClass.HasText()}" name="Save" ng-click="${clientEvents.onSubmit}?{clientEvents.onSubmit != null}" ng-disabled="${options.FormPanelId}.$pristine || ${options.FormPanelId}.$invalid">${Text(customText)}</button>
						!{options.RenderContent}
						<button if="options.EnableDelete" type="button" id="delete" class="delete btn btn-danger" name="Delete" ng-click="${clientEvents.onDelete}?{clientEvents.onDelete != null}">${Text('Common.Delete.Label')}</button>
						<button if="options.EnableCancel" type="button" id="cancel" class="cancel btn" name="Cancel" ng-click="${clientEvents.onCancel}?{clientEvents.onCancel != null}">${Text('Common.Cancel.Label')}</button>
					</div>
				</if>
				<else>
					!{options.RenderContent}
				</else>
			</span>
		</div>
	</else>
</macro>
